___TERMS_OF_SERVICE___

By creating or modifying this file you agree to Google Tag Manager's Community
Template Gallery Developer Terms of Service available at
https://developers.google.com/tag-manager/gallery-tos (or such other URL as
Google may provide), as modified from time to time.


___INFO___

{
  "displayName": "Salesforce Audience Studio",
  "description": "Formerly Salesforce DMP, Audience Studio can help you gain deep insights by unifying and capturing your data to strengthen customer relationships across every touchpoint with powerful data management",
  "categories": [
    "MARKETING"
  ],
  "securityGroups": [],
  "id": "cvt_temp_public_id",
  "type": "TAG",
  "version": 1,
  "brand": {
    "displayName": "Custom template created by Luratic",
    "id": "brand_dummy",
    "thumbnail": "data:image/png;base64,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"
  },
  "containerContexts": [
    "WEB"
  ]
}


___TEMPLATE_PARAMETERS___

[
  {
    "type": "TEXT",
    "name": "dataId",
    "displayName": "data-id",
    "simpleValueType": true,
    "help": "Insert the value of the data-id for the control talg provided by Salesforce",
    "valueValidators": [
      {
        "type": "NON_EMPTY"
      }
    ]
  },
  {
    "type": "TEXT",
    "name": "nsId",
    "displayName": "Namespace id",
    "simpleValueType": true,
    "valueHint": "ns:NAMESPACE"
  },
  {
    "type": "SELECT",
    "name": "route",
    "displayName": "Route",
    "selectItems": [
      {
        "value": "get",
        "displayValue": "get"
      },
      {
        "value": "set",
        "displayValue": "set"
      },
      {
        "value": "remove",
        "displayValue": "remove"
      },
      {
        "value": "portability",
        "displayValue": "portability"
      }
    ],
    "simpleValueType": true,
    "defaultValue": "set",
    "help": "Select the type of API request"
  },
  {
    "type": "GROUP",
    "name": "flags",
    "displayName": "Consent set flags",
    "groupStyle": "ZIPPY_OPEN",
    "subParams": [
      {
        "type": "CHECKBOX",
        "name": "dc",
        "checkboxText": "Enable data collection (dc)",
        "simpleValueType": true,
        "help": "\"dc\" flag: determines whether data collection is allowed",
        "defaultValue": true
      },
      {
        "type": "CHECKBOX",
        "name": "al",
        "checkboxText": "Enable analytics (al)",
        "simpleValueType": true,
        "help": "\"al\" flag: check it if you want to allow analytics",
        "defaultValue": true
      },
      {
        "type": "CHECKBOX",
        "name": "tg",
        "checkboxText": "Enable targeting (tg)",
        "simpleValueType": true,
        "help": "\"tg\" flag: check it if you want to allow targeting",
        "defaultValue": true
      },
      {
        "type": "CHECKBOX",
        "name": "cd",
        "checkboxText": "Enable cross-device linking (cd)",
        "simpleValueType": true,
        "help": "\"cd\" flag: check it if you want to enable cross-device linking",
        "defaultValue": true
      },
      {
        "type": "CHECKBOX",
        "name": "sh",
        "checkboxText": "Enable data sharing (sh)",
        "simpleValueType": true,
        "help": "\"sh\" flag: check it if you want to enable data sharing"
      },
      {
        "type": "CHECKBOX",
        "name": "re",
        "checkboxText": "Enable re-identification (re)",
        "simpleValueType": true,
        "help": "\"re\" flag: check it if you want to enable re-identification"
      }
    ],
    "help": "Check any of the following boxes to disable",
    "enablingConditions": [
      {
        "paramName": "route",
        "paramValue": "set",
        "type": "EQUALS"
      }
    ]
  },
  {
    "type": "SELECT",
    "name": "callback",
    "macrosInSelect": true,
    "selectItems": [],
    "simpleValueType": true,
    "help": "Function that will be called after the API request completes, in both success and failure cases. The first parameter of the callback function will receive the errors object of the API response in JSON form. The second parameter of the callback function will receive the body of the API response in JSON form. In order to make use of \u0027errors\u0027 and \u0027body\u0027 the javascript function passed here must be a closure (function returning another function). Eg:\nfunction () {\n  return function(errors, body) {\n    if (errors) {\n      console.error(errors);\n    } else {\n      console.log(body.settings);\n      if (body.settings.dc) {\n        console.log(\u0027This data subject allows data collection.\u0027);\n      }\n    }\n    return;\n  }\n}",
    "displayName": "Callback function",
    "enablingConditions": [
      {
        "paramName": "route",
        "paramValue": "get",
        "type": "EQUALS"
      }
    ]
  },
  {
    "type": "GROUP",
    "name": "optionalParams",
    "displayName": "Optional configuration",
    "groupStyle": "ZIPPY_CLOSED",
    "subParams": [
      {
        "type": "CHECKBOX",
        "name": "optflagsCheck",
        "checkboxText": "Use flags",
        "simpleValueType": true,
        "subParams": [
          {
            "type": "GROUP",
            "name": "optionalFlags",
            "displayName": "",
            "groupStyle": "NO_ZIPPY",
            "subParams": [
              {
                "type": "CHECKBOX",
                "name": "optDc",
                "checkboxText": "Enable data collection (dc)",
                "simpleValueType": true,
                "help": "\"dc\" flag: determines whether data collection is allowed"
              },
              {
                "type": "CHECKBOX",
                "name": "optAl",
                "checkboxText": "Enable analytics (al)",
                "simpleValueType": true,
                "help": "\"al\" flag: check it if you want to allow analytics"
              },
              {
                "type": "CHECKBOX",
                "name": "optTg",
                "checkboxText": "Enable targeting (tg)",
                "simpleValueType": true,
                "help": "\"tg\" flag: check it if you want to allow targeting"
              },
              {
                "type": "CHECKBOX",
                "name": "optCd",
                "checkboxText": "Enable cross-device linking (cd)",
                "simpleValueType": true,
                "help": "\"cd\" flag: check it if you want to enable cross-device linking"
              },
              {
                "type": "CHECKBOX",
                "name": "optSh",
                "checkboxText": "Enable data sharing (sh)",
                "simpleValueType": true,
                "help": "\"sh\" flag: check it if you want to enable data sharing"
              },
              {
                "type": "CHECKBOX",
                "name": "optRe",
                "checkboxText": "Enable re-identification (re)",
                "simpleValueType": true,
                "help": "\"re\" flag: check it if you want to enable re-identification"
              }
            ],
            "enablingConditions": [
              {
                "paramName": "optflagsCheck",
                "paramValue": true,
                "type": "EQUALS"
              }
            ]
          }
        ],
        "enablingConditions": [
          {
            "paramName": "route",
            "paramValue": "set",
            "type": "NOT_EQUALS"
          }
        ]
      },
      {
        "type": "GROUP",
        "name": "optParamsGroup",
        "displayName": "Optional parameters",
        "groupStyle": "NO_ZIPPY",
        "subParams": [
          {
            "type": "TEXT",
            "name": "idt",
            "displayName": "idt",
            "simpleValueType": true,
            "help": "The type of identifier that will be used:  bk or device",
            "valueValidators": [
              {
                "type": "REGEX",
                "args": [
                  "bk|device"
                ],
                "errorMessage": "The admited values for this field are \u0027bk\u0027 or \u0027device\u0027"
              }
            ]
          },
          {
            "type": "TEXT",
            "name": "dt",
            "displayName": "dt",
            "simpleValueType": true,
            "help": "If idt is device, this field is used to define which type of device is being used:  kxcookie, idfa, aaid, other (first party ID)"
          },
          {
            "type": "TEXT",
            "name": "bk",
            "displayName": "bk",
            "simpleValueType": true,
            "help": "Bridge key name; the attribute name of the bridge key passed in. This can be any bridge key attribute defined in your account."
          },
          {
            "type": "TEXT",
            "name": "idv",
            "displayName": "idv",
            "simpleValueType": true,
            "help": "An ID value, which may be a Krux cookie, advertiserId (from Android), IDFA (from iOS), first party ID, bridge key value (e.g., hashed), or some other identifier. Leave blank to have the Krux cookie looked up off the request."
          },
          {
            "type": "TEXT",
            "name": "pr",
            "displayName": "pr",
            "simpleValueType": true,
            "help": "Policy Regime the user falls under. If not given and we are unable to determine the policy regime through other means, the default policy regime will be used as configured for your organization. Currently, we support gdpr and global as the values."
          }
        ]
      },
      {
        "type": "CHECKBOX",
        "name": "checkCallback",
        "checkboxText": "Add custom callback function",
        "simpleValueType": true,
        "subParams": [
          {
            "type": "SELECT",
            "name": "optCallback",
            "displayName": "Select callback function",
            "macrosInSelect": true,
            "selectItems": [],
            "simpleValueType": true,
            "help": "Select the function that will be called after the API request completes, in both success and failure cases. The first parameter of the callback function will receive the errors object of the API response in JSON form. The second parameter of the callback function will receive the body of the API response in JSON form. In order to make use of \u0027errors\u0027 and \u0027body\u0027 the javascript function passed here must be a closure (function returning another function). E.g:\nfunction () {\n  return function(errors, body) {\n    if (errors) {\n      console.error(errors);\n    } else {\n      console.log(body.settings);\n      if (body.settings.dc) {\n        console.log(\u0027This data subject allows data collection.\u0027);\n      }\n    }\n    return;\n  }\n}",
            "enablingConditions": [
              {
                "paramName": "checkCallback",
                "paramValue": true,
                "type": "EQUALS"
              }
            ]
          }
        ],
        "enablingConditions": [
          {
            "paramName": "route",
            "paramValue": "get",
            "type": "NOT_EQUALS"
          }
        ]
      }
    ],
    "help": "If you change the default value for device type (dt) you\u0027ll need also to set values for idt and idv"
  },
  {
    "type": "CHECKBOX",
    "name": "consoleLogging",
    "checkboxText": "Enable debug messages",
    "simpleValueType": true,
    "help": "Log debug messages to the console"
  }
]


___SANDBOXED_JS_FOR_WEB_TEMPLATE___

const callInWindow = require('callInWindow');
const copyFromWindow = require('copyFromWindow');
const createQueue = require('createQueue');
const injectScript = require('injectScript');
const setInWindow = require('setInWindow');
const encodeUri = require('encodeUri');

const log = data.consoleLogging ? require('logToConsole') : (() => {});
// check if the object is empty
const isEmpty = (obj) => {
  for (let key in obj) {
    if (obj.hasOwnProperty(key))
      return false;
  }
  return true;
};

const getKruxFunction = () => {
  // Return the existing 'Krux' global method if available
  let kruxFunc = copyFromWindow('Krux');
  if (kruxFunc) {
    return kruxFunc;
  }
  setInWindow('Krux', function () {
    callInWindow('Krux.q.push', arguments);
  });
  // Create the Krux queue
  createQueue('Krux.q');
  // Return the global 'Krux' method, created above
  return copyFromWindow('Krux');
};

const Krux = getKruxFunction();

// callback selected via the template interface
const customCallback = data.checkCallback ? data.optCallback : data.callback;

const callback = (errors, body) => {
  if (errors) {
    log('Audience Studio Consent tag failed: ', errors);
  } else if (body) {
    log('Audience Studio Consent tag executed successfully. Request body: ', body);
  } else {
    log('Audience Studio Consent tag executed successfully');
  }
  
  // excute custom callback if defined
  if (customCallback) {
    customCallback(errors, body);
  }

};

const scriptSrc = encodeUri('https://cdn.krxd.net/controltag/' + data.dataId + '.js');
const namespaceId = data.nsId;
const route = 'consent:' + data.route;

let params;

// define the params object adding flags if exist
if (data.route === 'set') {
  params = {
    dc: data.dc,
    al: data.al,
    tg: data.tg,
    cd: data.cd,
    sh: data.sh,
    re: data.re
  };
} else if (data.optflagsCheck) {
  params = {
    dc: data.optDc,
    al: data.optAl,
    tg: data.optTg,
    cd: data.optCd,
    sh: data.optSh,
    re: data.optRe
  };
} else {
  params = {};
}

// set optional parameters
if (data.idt) {
  params.idt = data.idt;
}

if (data.dt) {
  params.dt = data.dt;
}

if (data.bk) {
  params.bk = data.bk;
}

if (data.idv) {
  params.idv = data.idv;
}

if (data.pr) {
  params.dt = data.pr;
}

// if params object is empty we set the variable as undefined
params = isEmpty(params) ? undefined : params;
// if no callback was provided we use the default callback

const onSuccess = () => {
  // choose and invoke the method depending on available parameters
  switch (true) {
    case namespaceId !== undefined && params !== undefined:
      Krux(namespaceId, route, params, callback);
      break;
    case namespaceId !== undefined:
      Krux(namespaceId, route, callback);
      break;
    case params !== undefined:
      Krux(route, params, callback);
      break;
    default:
      Krux(route, callback);
  }
  data.gtmOnSuccess();
};

const onFailure = () => {
	log('Failed to load Audience Studio Control Tag');
  	data.gtmOnFailure();
};

injectScript(scriptSrc, onSuccess, onFailure);


___WEB_PERMISSIONS___

[
  {
    "instance": {
      "key": {
        "publicId": "access_globals",
        "versionId": "1"
      },
      "param": [
        {
          "key": "keys",
          "value": {
            "type": 2,
            "listItem": [
              {
                "type": 3,
                "mapKey": [
                  {
                    "type": 1,
                    "string": "key"
                  },
                  {
                    "type": 1,
                    "string": "read"
                  },
                  {
                    "type": 1,
                    "string": "write"
                  },
                  {
                    "type": 1,
                    "string": "execute"
                  }
                ],
                "mapValue": [
                  {
                    "type": 1,
                    "string": "Krux"
                  },
                  {
                    "type": 8,
                    "boolean": true
                  },
                  {
                    "type": 8,
                    "boolean": true
                  },
                  {
                    "type": 8,
                    "boolean": true
                  }
                ]
              },
              {
                "type": 3,
                "mapKey": [
                  {
                    "type": 1,
                    "string": "key"
                  },
                  {
                    "type": 1,
                    "string": "read"
                  },
                  {
                    "type": 1,
                    "string": "write"
                  },
                  {
                    "type": 1,
                    "string": "execute"
                  }
                ],
                "mapValue": [
                  {
                    "type": 1,
                    "string": "Krux.q.push"
                  },
                  {
                    "type": 8,
                    "boolean": false
                  },
                  {
                    "type": 8,
                    "boolean": false
                  },
                  {
                    "type": 8,
                    "boolean": true
                  }
                ]
              },
              {
                "type": 3,
                "mapKey": [
                  {
                    "type": 1,
                    "string": "key"
                  },
                  {
                    "type": 1,
                    "string": "read"
                  },
                  {
                    "type": 1,
                    "string": "write"
                  },
                  {
                    "type": 1,
                    "string": "execute"
                  }
                ],
                "mapValue": [
                  {
                    "type": 1,
                    "string": "Krux.q"
                  },
                  {
                    "type": 8,
                    "boolean": true
                  },
                  {
                    "type": 8,
                    "boolean": true
                  },
                  {
                    "type": 8,
                    "boolean": false
                  }
                ]
              }
            ]
          }
        }
      ]
    },
    "clientAnnotations": {
      "isEditedByUser": true
    },
    "isRequired": true
  },
  {
    "instance": {
      "key": {
        "publicId": "logging",
        "versionId": "1"
      },
      "param": [
        {
          "key": "environments",
          "value": {
            "type": 1,
            "string": "debug"
          }
        }
      ]
    },
    "isRequired": true
  },
  {
    "instance": {
      "key": {
        "publicId": "inject_script",
        "versionId": "1"
      },
      "param": [
        {
          "key": "urls",
          "value": {
            "type": 2,
            "listItem": [
              {
                "type": 1,
                "string": "https://cdn.krxd.net/controltag/*"
              }
            ]
          }
        }
      ]
    },
    "clientAnnotations": {
      "isEditedByUser": true
    },
    "isRequired": true
  }
]


___TESTS___

scenarios:
- name: gtmOnSuccess is invoked on injectScript success
  code: |-
    // test that gtmOnSuccess() is called when injectScript succeeds
    mock('injectScript', (url, onSuccess, onFailure) => {
      onSuccess();
    });

    // Call runCode to run the template's code.
    runCode();

    // Verify that the tag finished successfully.
    assertApi('gtmOnSuccess').wasCalled();
- name: gtmOnFailure is invoked when injectScript fails
  code: |-
    // test gtmOnFailure() is called when injectScript fails
    mock('injectScript', (url, onSuccess, onFailure) => {
      onFailure();
    });

    // Call runCode to run the template's code.
    runCode();

    // Verify onFailure was called
    assertApi('gtmOnFailure').wasCalled();
- name: Don't make uneeded api calls when Krux function already exists in window
  code: |+
    // If Krux already exist in window it should be used and therefore there's no need to call other apis to create it
    mock('copyFromWindow', (name) => 'Krux');

    // Call runCode to run the template's code.
    runCode();

    assertApi('setInWindow').wasNotCalled();
    assertApi('callInWindow').wasNotCalled();
    assertApi('createQueue').wasNotCalled();
    assertApi('copyFromWindow').wasCalled(1); // copyFromWindow was only called in the mock above



- name: Do needed api calls when Krux function doesn't exist in window
  code: "// If Krux doesn't exist in window, some setInWindow, createQueue and copyFromWindow\
    \ should be called\nmock('copyFromWindow', (name) => undefined);\n\n// Call runCode\
    \ to run the template's code.\nrunCode();\n\nassertApi('setInWindow').wasCalled();\n\
    assertApi('createQueue').wasCalled();\nassertApi('copyFromWindow').wasCalled(2);\
    \ // copyFromWindow called in the mock above and also in the template code "
- name: Log debug messages when user checked this option
  code: |-
    // checks that debug messages are logged when the user selects this options in the template configuration
    const mockSetData = {
      consoleLogging: true
    };


    mock('injectScript', (url, onSuccess, onFailure) => {
      onFailure();
    });

    // Call runCode to run the template's code.
    runCode(mockSetData);

    // Verify api calls
    assertApi('logToConsole').wasCalled();
- name: Don't log debug messages when user didn't check this option
  code: |-
    // checks that debug messages are logged when the user selects this options in the template configuration
    const mockSetData = {
      consoleLogging: false
    };

    mock('injectScript', (url, onSuccess, onFailure) => {
      onFailure();
    });

    // Call runCode to run the template's code.
    runCode(mockSetData);

    // Verify api calls
    assertApi('logToConsole').wasNotCalled();
setup: ''


___NOTES___

Developed with ❤ by: Alfonso, Txema and Brais.
Web: www.luratic.com
Linkedin: 
https://www.linkedin.com/in/braiscalvo/
https://www.linkedin.com/in/alfonsorc/
https://www.linkedin.com/in/txema-s%C3%A1nchez-a48482ba/


